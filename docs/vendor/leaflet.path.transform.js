(function(m,s){typeof exports=="object"&&typeof module<"u"?s(exports,require("leaflet")):typeof define=="function"&&define.amd?define(["exports","leaflet"],s):(m=typeof globalThis<"u"?globalThis:m||self,s(m.PathTransform={},m.L))})(this,function(m,s){"use strict";/**
* Drag/rotate/resize handler for [leaflet](http://leafletjs.com) vector features.
*
* @author Alexander Milevski <info@w8r.name>
* @license MIT
* @preserve
*/s.SVG.include({_resetTransformPath:function(t){t._path.setAttributeNS(null,"transform","")},transformPath:function(t,i){t._path.setAttributeNS(null,"transform","matrix("+i.join(" ")+")")}}),s.SVG.include(s.Browser.vml?{_resetTransformPath:function(t){t._skew&&(t._skew.on=!1,t._path.removeChild(t._skew),t._skew=null)},transformPath:function(t,i){let n=t._skew;n||(n=s.SVG.create("skew"),t._path.appendChild(n),n.style.behavior="url(#default#VML)",t._skew=n);const a=i[0].toFixed(8)+" "+i[1].toFixed(8)+" "+i[2].toFixed(8)+" "+i[3].toFixed(8)+" 0 0",e=Math.floor(i[4]).toFixed()+", "+Math.floor(i[5]).toFixed(),r=this._path.style;let h=parseFloat(r.left),o=parseFloat(r.top),_=parseFloat(r.width),d=parseFloat(r.height);isNaN(h)&&(h=0),isNaN(o)&&(o=0),(isNaN(_)||!_)&&(_=1),(isNaN(d)||!d)&&(d=1);const p=(-h/_-.5).toFixed(8)+" "+(-o/d-.5).toFixed(8);n.on="f",n.matrix=a,n.origin=p,n.offset=e,n.on=!0}}:{});function w(){return!0}s.Canvas.include({_resetTransformPath:function(t){this._containerCopy&&(delete this._containerCopy,t._containsPoint_&&(t._containsPoint=t._containsPoint_,delete t._containsPoint_,this._requestRedraw(t)))},transformPath:function(t,i){let n=this._containerCopy;const a=this._ctx;let e;const r=s.Browser.retina?2:1,h=this._bounds,o=h.getSize(),_=h.min;n||(n=this._containerCopy=document.createElement("canvas"),e=n.getContext("2d"),n.width=r*o.x,n.height=r*o.y,this._removePath(t),this._redraw(),e.translate(r*h.min.x,r*h.min.y),e.drawImage(this._container,0,0),this._initPath(t),t._containsPoint_=t._containsPoint,t._containsPoint=w),a.save(),a.clearRect(_.x,_.y,o.x*r,o.y*r),a.setTransform(1,0,0,1,0,0),a.restore(),a.save(),a.drawImage(this._containerCopy,0,0,o.x,o.y),a.transform.apply(a,i),this._drawing=!0,t._updatePath(),this._drawing=!1,a.restore()}});/**
 * Leaflet vector features drag functionality
 * @author Alexander Milevski <info@w8r.name>
 * @preserve
 */s.Path.include({_transform:function(t){return this._renderer&&(t?this._renderer.transformPath(this,t):(this._renderer._resetTransformPath(this),this._update())),this},_onMouseClick:function(t){this.dragging&&this.dragging.moved()||this._map.dragging&&this._map.dragging.moved()||this._fireMouseEvent(t)}});const D={mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},k={mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"};function S(t,i){const n=t.x-i.x,a=t.y-i.y;return Math.sqrt(n*n+a*a)}s.Handler.PathDrag=s.Handler.extend({statics:{DRAGGING_CLS:"leaflet-path-draggable"},initialize:function(t){this._path=t,this._matrix=null,this._startPoint=null,this._dragStartPoint=null,this._mapDraggingWasEnabled=!1,this._path._dragMoved=!1},addHooks:function(){this._path.on("mousedown",this._onDragStart,this),this._path.options.className=this._path.options.className?this._path.options.className+" "+s.Handler.PathDrag.DRAGGING_CLS:s.Handler.PathDrag.DRAGGING_CLS,this._path._path&&s.DomUtil.addClass(this._path._path,s.Handler.PathDrag.DRAGGING_CLS)},removeHooks:function(){this._path.off("mousedown",this._onDragStart,this),this._path.options.className=this._path.options.className.replace(new RegExp("\\s+"+s.Handler.PathDrag.DRAGGING_CLS),""),this._path._path&&s.DomUtil.removeClass(this._path._path,s.Handler.PathDrag.DRAGGING_CLS)},moved:function(){return this._path._dragMoved},_onDragStart:function(t){const i=t.originalEvent._simulated?"touchstart":t.originalEvent.type;this._mapDraggingWasEnabled=!1,this._startPoint=t.containerPoint.clone(),this._dragStartPoint=t.containerPoint.clone(),this._matrix=[1,0,0,1,0,0],s.DomEvent.stop(t.originalEvent),s.DomUtil.addClass(this._path._renderer._container,"leaflet-interactive"),s.DomEvent.on(document,k[i],this._onDrag,this).on(document,D[i],this._onDragEnd,this),this._path._map.dragging.enabled()&&(this._path._map.dragging.disable(),this._mapDraggingWasEnabled=!0),this._path._dragMoved=!1,this._path._popup&&this._path._popup.close(),this._replaceCoordGetters(t)},_onDrag:function(t){s.DomEvent.stop(t);const i=t.touches&&t.touches.length>=1?t.touches[0]:t,n=this._path._map.mouseEventToContainerPoint(i);if(t.type==="touchmove"&&!this._path._dragMoved&&this._dragStartPoint.distanceTo(n)<=this._path._map.options.tapTolerance)return;const a=n.x,e=n.y,r=a-this._startPoint.x,h=e-this._startPoint.y;(r||h)&&(this._path._dragMoved||(this._path._dragMoved=!0,this._path.options.interactive=!1,this._path._map.dragging._draggable._moved=!0,this._path.fire("dragstart",t),this._path.bringToFront()),this._matrix[4]+=r,this._matrix[5]+=h,this._startPoint.x=a,this._startPoint.y=e,this._path.fire("predrag",t),this._path._transform(this._matrix),this._path.fire("drag",t))},_onDragEnd:function(t){const i=this._path._map.mouseEventToContainerPoint(t),n=this.moved();if(n&&(this._transformPoints(this._matrix),this._path._updatePath(),this._path._project(),this._path._transform(null),s.DomEvent.stop(t)),s.DomEvent.off(document,"mousemove touchmove",this._onDrag,this),s.DomEvent.off(document,"mouseup touchend",this._onDragEnd,this),this._restoreCoordGetters(),n){this._path.fire("dragend",{distance:S(this._dragStartPoint,i)});const a=this._path._containsPoint;this._path._containsPoint=s.Util.falseFn,s.Util.requestAnimFrame(function(){this._path._dragMoved=!1,this._path.options.interactive=!0,this._path._containsPoint=a},this)}this._mapDraggingWasEnabled&&this._path._map.dragging.enable()},_transformPoints:function(t,i){const n=this._path,a=L.point(t[4],t[5]),e=n._map.options.crs,r=e.transformation,h=e.scale(n._map.getZoom()),o=e.projection,_=r.untransform(a,h).subtract(r.untransform(s.point(0,0),h)),d=!i;if(n._bounds=new s.LatLngBounds,n._point)i=o.unproject(o.project(n._latlng)._add(_)),d&&(n._latlng=i,n._point._add(a));else if(n._rings||n._parts){const p=n._rings||n._parts;let c=n._latlngs;i=i||c,s.Util.isArray(c[0])||(c=[c],i=[i]);for(let l=0,f=p.length;l<f;l++){i[l]=i[l]||[];for(let g=0,T=p[l].length;g<T;g++){const E=c[l][g];i[l][g]=o.unproject(o.project(E)._add(_)),d&&(n._bounds.extend(c[l][g]),p[l][g]._add(a))}}}return i},_replaceCoordGetters:function(){this._path.getLatLng?(this._path.getLatLng_=this._path.getLatLng,this._path.getLatLng=s.Util.bind(function(){return this.dragging._transformPoints(this.dragging._matrix,{})},this._path)):this._path.getLatLngs&&(this._path.getLatLngs_=this._path.getLatLngs,this._path.getLatLngs=s.Util.bind(function(){return this.dragging._transformPoints(this.dragging._matrix,[])},this._path))},_restoreCoordGetters:function(){this._path.getLatLng_?(this._path.getLatLng=this._path.getLatLng_,delete this._path.getLatLng_):this._path.getLatLngs_&&(this._path.getLatLngs=this._path.getLatLngs_,delete this._path.getLatLngs_)}}),s.Handler.PathDrag.makeDraggable=function(t){return t.dragging=new s.Handler.PathDrag(t),t},s.Path.prototype.makeDraggable=function(){return s.Handler.PathDrag.makeDraggable(this)},s.Path.addInitHook(function(){this.options.draggable?(this.options.interactive=!0,this.dragging?this.dragging.enable():(s.Handler.PathDrag.makeDraggable(this),this.dragging.enable())):this.dragging&&this.dragging.disable()});const G=s.Handler.PathDrag,v=(t,i,n)=>{var a=1+n/t.distanceTo(i);return new L.Point(t.x+(i.x-t.x)*a,t.y+(i.y-t.y)*a)},b=(...t)=>{var i=1,n,a,e=t[i];function r(o){return Object.prototype.toString.call(o)==="[object Object]"}for(var h=t[0];e;){e=t[i++];for(n in e)e.hasOwnProperty(n)&&(a=e[n],r(a)&&r(h[n])?h[n]=L.PathTransform.merge(h[n],a):h[n]=a)}return h},H=Object.freeze(Object.defineProperty({__proto__:null,merge:b,pointOnLine:v},Symbol.toStringTag,{value:"Module"}));class u{constructor(i,n,a,e,r,h){this._matrix=[i,n,a,e,r,h]}transform(i){return this._transform(i.clone())}_transform(i){const n=this._matrix,a=i.x,e=i.y;return i.x=n[0]*a+n[1]*e+n[4],i.y=n[2]*a+n[3]*e+n[5],i}untransform(i){const n=this._matrix;return new s.Point((i.x/n[0]-n[4])/n[0],(i.y/n[2]-n[5])/n[2])}clone(){const i=this._matrix;return new u(i[0],i[1],i[2],i[3],i[4],i[5])}translate(i){if(i===void 0)return new s.Point(this._matrix[4],this._matrix[5]);let n,a;return typeof i=="number"?n=a=i:(n=i.x,a=i.y),this._add(1,0,0,1,n,a)}scale(i,n){if(i===void 0)return new s.Point(this._matrix[0],this._matrix[3]);let a,e;return n=n||new s.Point(0,0),typeof i=="number"?a=e=i:(a=i.x,e=i.y),this._add(a,0,0,e,n.x,n.y)._add(1,0,0,1,-n.x,-n.y)}rotate(i,n){const a=Math.cos(i),e=Math.sin(i);return n=n||new s.Point(0,0),this._add(a,e,-e,a,n.x,n.y)._add(1,0,0,1,-n.x,-n.y)}flip(){return this._matrix[1]*=-1,this._matrix[2]*=-1,this}_add(i,n,a,e,r,h){const o=[[],[],[]];let _=this._matrix;const d=[[_[0],_[2],_[4]],[_[1],_[3],_[5]],[0,0,1]];let p=[[i,a,r],[n,e,h],[0,0,1]],c;i&&i instanceof u&&(_=i._matrix,p=[[_[0],_[2],_[4]],[_[1],_[3],_[5]],[0,0,1]]);for(let l=0;l<3;l++)for(let f=0;f<3;f++){c=0;for(let g=0;g<3;g++)c+=d[l][g]*p[g][f];o[l][f]=c}return this._matrix=[o[0][0],o[1][0],o[0][1],o[1][1],o[0][2],o[1][2]],this}}const y=(t,i,n,a,e,r)=>new u(t,i,n,a,e,r),C=["nesw-resize","nwse-resize","nesw-resize","nwse-resize"],P=s.CircleMarker.extend({options:{className:"leaflet-path-transform-handler"},onAdd:function(t){s.CircleMarker.prototype.onAdd.call(this,t),this._path&&this.options.setCursor&&(this._path.style.cursor=C[this.options.index])}}),M=P.extend({options:{className:"leaflet-path-transform-handler transform-handler--rotate"},onAdd(t){s.CircleMarker.prototype.onAdd.call(this,t),this._path&&this.options.setCursor&&(this._path.style.cursor="all-scroll")}}),x=s.Handler.extend({options:{rotation:!0,scaling:!0,uniformScaling:!0,maxZoom:22,handlerOptions:{radius:5,fillColor:"#ffffff",color:"#202020",fillOpacity:1,weight:2,opacity:.7,setCursor:!0},boundsOptions:{weight:1,opacity:1,dashArray:[3,3],fill:!1,noClip:!0},rotateHandleOptions:{weight:1,opacity:1,setCursor:!0},handleLength:20,edgesCount:4,handleClass:P,rotateHandleClass:M},initialize(t){this._path=t,this._map=null,this._activeMarker=null,this._originMarker=null,this._rotationMarker=null,this._rotationOrigin=null,this._scaleOrigin=null,this._angle=0,this._scale=s.point(1,1),this._initialDist=0,this._initialDistX=0,this._initialDistY=0,this._rotationStart=null,this._rotationOriginPt=null,this._matrix=new u(1,0,0,1,0,0),this._projectedMatrix=new u(1,0,0,1,0,0),this._handlersGroup=null,this._rect=null,this._handlers=[],this._handleLine=null},enable(t){this._path._map&&(this._map=this._path._map,t&&this.setOptions(t),s.Handler.prototype.enable.call(this))},addHooks(){this._createHandlers(),this._path.on("dragstart",this._onDragStart,this).on("dragend",this._onDragEnd,this)},removeHooks(){this._hideHandlers(),this._path.off("dragstart",this._onDragStart,this).off("dragend",this._onDragEnd,this),this._handlersGroup=null,this._rect=null,this._handlers=[]},setOptions(t){const i=this._enabled;return i&&this.disable(),this.options=b({},x.prototype.options,t),i&&this.enable(),this},rotate(t,i){return this.transform(t,null,i)},scale(t,i){return typeof t=="number"&&(t=s.point(t,t)),this.transform(0,t,null,i)},transform(t,i,n,a){const e=this._path.getCenter();return n=n||e,a=a||e,this._map=this._path._map,this._transformPoints(this._path,t,i,n,a),this._transformPoints(this._rect,t,i,n,a),this._transformPoints(this._handleLine,t,i,n,a),this._updateHandlers(),this},_update(){const t=this._matrix;for(const i of this._handlers)i!==this._originMarker&&(i._point=t.transform(i._initialPoint),i._updatePath());this._applyTransform(t.clone().flip()),this._path.fire("transform",{layer:this._path})},_applyTransform(t){this._path._transform(t._matrix),this._rect._transform(t._matrix),this.options.rotation&&this._handleLine._transform(t._matrix)},_apply(){const t=this._map,i=this._matrix.clone(),n=this._angle,a=this._scale.clone();this._transformGeometries();for(const e of this._handlers)e._latlng=t.layerPointToLatLng(e._point),delete e._initialPoint,e.redraw();this._matrix=new u(1,0,0,1,0,0),this._scale=s.point(1,1),this._angle=0,this._updateHandlers(),t.dragging.enable(),this._path.fire("transformed",{matrix:i,scale:a,rotation:n,layer:this._path})},reset(){this._enabled&&(this._rect&&(this._handlersGroup.removeLayer(this._rect),this._rect=this._getBoundingPolygon().addTo(this._handlersGroup)),this._updateHandlers())},_updateHandlers(){const t=this._handlersGroup;this._rectShape=this._rect.toGeoJSON(),this._handleLine&&this._handlersGroup.removeLayer(this._handleLine),this._rotationMarker&&this._handlersGroup.removeLayer(this._rotationMarker),this._handleLine=this._rotationMarker=null;for(let i=this._handlers.length-1;i>=0;i--)t.removeLayer(this._handlers[i]);this._createHandlers()},_transformGeometries(){this._path._transform(null),this._rect._transform(null),this._transformPoints(this._path),this._transformPoints(this._rect),this.options.rotation&&(this._handleLine._transform(null),this._transformPoints(this._handleLine,this._angle,null,this._origin))},_getProjectedMatrix(t,i,n,a){const e=this._map,r=e.getMaxZoom()||this.options.maxZoom;let h=y(1,0,0,1,0,0),o;return t=t||this._angle||0,i=i||this._scale||s.point(1,1),i.x===1&&i.y===1||(a=a||this._scaleOrigin,o=e.project(a,r),h=h._add(y(1,0,0,1,o.x,o.y))._add(y(i.x,0,0,i.y,0,0))._add(y(1,0,0,1,-o.x,-o.y))),t&&(n=n||this._rotationOrigin,o=e.project(n,r),h=h.rotate(t,o).flip()),h},_transformPoint(t,i,n,a){return n.unproject(i.transform(n.project(t,a)),a)},_transformPoints(t,i,n,a,e){const r=t._map,h=r.getMaxZoom()||this.options.maxZoom,o=this._projectedMatrix=this._getProjectedMatrix(i,n,a,e);if(t._point){t._latlng=this._transformPoint(t._latlng,o,r,h);const _=this._getBoundingPolygon(),d=Math.floor(Math.abs(_._bounds._southWest.lat-_._bounds._northEast.lat)/2);t.setRadius(d)}else if(t._rings||t._parts){const _=t._rings;let d=t._latlngs;t._bounds=new s.LatLngBounds,s.Util.isArray(d[0])||(d=[d]);for(let p=0,c=_.length;p<c;p++)for(let l=0,f=_[p].length;l<f;l++)d[p][l]=this._transformPoint(d[p][l],o,r,h),t._bounds.extend(d[p][l])}t._reset()},_createHandlers(){const t=this._map;if(this._handlersGroup=this._handlersGroup||new s.LayerGroup().addTo(t),this._rect=this._rect||this._getBoundingPolygon().addTo(this._handlersGroup),this.options.scaling){this._handlers=[];for(let i=0;i<this.options.edgesCount;i++)this._handlers.push(this._createHandler(this._rect._latlngs[0][i],i*2,i).addTo(this._handlersGroup))}this.options.rotation&&this._createRotationHandlers(),this._handlersGroup.getLayers().forEach(function(i){i.bringToFront()})},_createRotationHandlers(){const t=this._map,i=this._rect._latlngs[0],n=s.latLng((i[0].lat+i[3].lat)/2,(i[0].lng+i[3].lng)/2),a=s.latLng((i[1].lat+i[2].lat)/2,(i[1].lng+i[2].lng)/2),e=t.layerPointToLatLng(v(t.latLngToLayerPoint(n),t.latLngToLayerPoint(a),this.options.handleLength));this._handleLine=new s.Polyline([a,e],this.options.rotateHandleOptions).addTo(this._handlersGroup);const r=this.options.rotateHandleClass;this._rotationMarker=new r(e,this.options.handlerOptions).addTo(this._handlersGroup).on("mousedown",this._onRotateStart,this),this._rotationOrigin=s.latLng((a.lat+n.lat)/2,(a.lng+n.lng)/2),this._handlers.push(this._rotationMarker)},_getRotationOrigin(){const t=this._rect._latlngs[0],i=t[0],n=t[2];return s.latLng((i.lat+n.lat)/2,(i.lng+n.lng)/2)},_onRotateStart(t){this._map.dragging.disable(),this._originMarker=null,this._rotationOriginPt=this._map.latLngToLayerPoint(this._getRotationOrigin()),this._rotationStart=t.layerPoint,this._initialMatrix=this._matrix.clone();const i=t.originalEvent._simulated;console.log({isTouch:i}),this._angle=0,this._path._map.on(i?"touchmove":"mousemove",this._onRotate,this).on(i?"touchend":"mouseup",this._onRotateEnd,this),this._cachePoints(),this._path.fire("transformstart",{layer:this._path}).fire("rotatestart",{layer:this._path,rotation:0})},_onRotate(t){s.DomEvent.stop(t);const i=t.layerPoint,n=this._rotationStart,a=this._rotationOriginPt;this._angle=Math.atan2(i.y-a.y,i.x-a.x)-Math.atan2(n.y-a.y,n.x-a.x),this._matrix=this._initialMatrix.clone().rotate(this._angle,a).flip(),this._update(),this._path.fire("rotate",{layer:this._path,rotation:this._angle})},_onRotateEnd(){this._path._map.off("mousemove touchmove",this._onRotate,this).off("mouseup touchend",this._onRotateEnd,this);const t=this._angle;this._apply(),this._path.fire("rotateend",{layer:this._path,rotation:t})},_onScaleStart(t){const i=t.target,n=this._map,a=t.originalEvent._simulated;n.dragging.disable(),this._activeMarker=i,this._originMarker=this._handlers[(i.options.index+2)%4],this._scaleOrigin=this._originMarker.getLatLng(),this._initialMatrix=this._matrix.clone(),this._cachePoints(),this._map.on(a?"touchmove":"mousemove",this._onScale,this).on(a?"touchend":"mouseup",this._onScaleEnd,this),this._initialDist=this._originMarker._point.distanceTo(this._activeMarker._point),this._initialDistX=this._originMarker._point.x-this._activeMarker._point.x,this._initialDistY=this._originMarker._point.y-this._activeMarker._point.y,this._path.fire("transformstart",{layer:this._path}).fire("scalestart",{layer:this._path,scale:L.point(1,1)}),this._handleLine&&this._map.removeLayer(this._handleLine),this._rotationMarker&&this._map.removeLayer(this._rotationMarker)},_onScale(t){const i=this._originMarker._point;let n,a;this.options.uniformScaling?(n=i.distanceTo(t.layerPoint)/this._initialDist,a=n):(n=(i.x-t.layerPoint.x)/this._initialDistX,a=(i.y-t.layerPoint.y)/this._initialDistY),this._scale=s.point(n,a),this._matrix=this._initialMatrix.clone().scale(this._scale,i),this._update(),this._path.fire("scale",{layer:this._path,scale:this._scale.clone()})},_onScaleEnd(){this._map.off("mousemove touchmove",this._onScale,this).off("mouseup touchend",this._onScaleEnd,this),this._handleLine&&this._map.addLayer(this._handleLine),this._rotationMarker&&this._map.addLayer(this._rotationMarker),this._apply(),this._path.fire("scaleend",{layer:this._path,scale:this._scale.clone()})},_cachePoints(){this._handlersGroup.eachLayer(t=>t.bringToFront());for(const t of this._handlers)t._initialPoint=t._point.clone()},_getBoundingPolygon(){return this._rectShape?s.GeoJSON.geometryToLayer(this._rectShape,this.options.boundsOptions):new s.Rectangle(this._path.getBounds(),this.options.boundsOptions)},_createHandler(t,i,n){const a=this.options.handleClass,e=new a(t,s.Util.extend({},this.options.handlerOptions,{className:"leaflet-drag-transform-marker drag-marker--"+n+" drag-marker--"+i,index:n,type:i}));return e.on("mousedown",this._onScaleStart,this),e},_hideHandlers(){this._map.removeLayer(this._handlersGroup)},_onDragStart(){this._hideHandlers()},_onDragEnd(t){const i=this._rect,n=(t.layer?t.layer:this._path).dragging._matrix.slice();i.dragging||(i.dragging=new G(i)),i.dragging.enable(),this._map.addLayer(i),i.dragging._transformPoints(n),i._updatePath(),i._project(),i.dragging.disable(),this._map.addLayer(this._handlersGroup),this._updateHandlers(),this._path.fire("transformed",{scale:L.point(1,1),rotation:0,matrix:new u(...n),translate:s.point(n[4],n[5]),layer:this._path})}});s.Handler.RotateHandle=M,s.Handler.Handle=P,s.Path.addInitHook(function(){this.options.transform&&(this.transform=new x(this,this.options.transform))}),s.Handler.PathTransform=x,m.Matrix=u,m.Transform=x,m.Util=H,m.matrix=y,Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});
